<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ProtPeptigram.viz API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ProtPeptigram.viz</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ProtPeptigram.viz.ImmunoViz"><code class="flex name class">
<span>class <span class="ident">ImmunoViz</span></span>
<span>(</span><span>peptide_data: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImmunoViz:
    &#34;&#34;&#34;
    A visualization tool for immunopeptide data from mass spectrometry results.
    Enhanced version with sequential colormaps and advanced visualization options.
    &#34;&#34;&#34;
    
    def __init__(self, peptide_data: pd.DataFrame):
        &#34;&#34;&#34;
        Initialize the ImmunoViz object with peptide data.
        
        Parameters:
        -----------
        peptide_data : pd.DataFrame
            DataFrame containing peptide information with columns:
            - Peptide: sequence of the peptide
            - Protein: protein identifier
            - Start: start position in the protein
            - End: end position in the protein
            - Intensity: intensity value from mass spec
            - Sample: sample identifier
        &#34;&#34;&#34;
        self.peptide_data = peptide_data.copy()
        
        # Set default visualization parameters
        self.font_family = &#34;Arial&#34;
        plt.rcParams[&#34;font.family&#34;] = self.font_family
        
        # Nature journal inspired color palette for proteins
        self.protein_colors = [
            &#34;#4C72B0&#34;, &#34;#DD8452&#34;, &#34;#55A868&#34;, &#34;#C44E52&#34;, &#34;#8172B3&#34;,  # Main colors
            &#34;#937860&#34;, &#34;#DA8BC3&#34;, &#34;#8C8C8C&#34;, &#34;#CCB974&#34;, &#34;#64B5CD&#34;   # Secondary colors
        ]
    
    # Update the plot_peptigram method with these improvements
    def plot_peptigram(
        self,
        protein_ids: Union[str, List[str]],
        groups: List[str] = None,
        group_by: str = &#39;Sample&#39;,
        color_by: str = &#39;protein&#39;,
        figsize: Tuple[int, int] = (12, 10),
        title: Optional[str] = None,
        annotate: bool = True,
        min_intensity: Optional[float] = None,
        highlight_regions: Optional[List[Tuple[int, int]]] = None,
        auto_highlight: bool = True,
        auto_highlight_window: int = 10,
        auto_highlight_threshold: float = 0.8,
        highlight: bool = True,
        color_by_protein_and_intensity: bool = False,
        intensity_color_scale: float = 0.7,
        intensity_cmaps: Union[str, List[str]] = &#34;viridis&#34;,
        protein_cmap: str = &#34;tab10&#34;,
        external_legend: bool = True,
        highlight_alpha: float = 0.25,
        highlight_color: str = &#34;#FF8888&#34;,
        dpi: int = 100
    ):
        &#34;&#34;&#34;
        Create a PeptiGram visualization with protein-based coloring.
        
        Parameters:
        -----------
        protein_ids : str or List[str]
            Protein identifier(s) to visualize
        groups : List[str], optional
            List of group names to include (if None, all groups are included)
        group_by : str, optional
            Column name to group samples by (default: &#39;Sample&#39;)
        color_by : str, optional
            How to color peptides: &#39;intensity&#39;, &#39;count&#39;, &#39;length&#39;, or &#39;protein&#39; (default: &#39;protein&#39;)
        figsize : Tuple[int, int], optional
            Figure size (width, height) in inches (default: (12, 10))
        title : str, optional
            Title for the plot (default: &#34;Protein Peptide Coverage&#34;)
        annotate : bool, optional
            Whether to annotate proteins (default: True)
        min_intensity : float, optional
            Minimum intensity threshold (default: None)
        highlight_regions : List[Tuple[int, int]], optional
            List of (start, end) regions to highlight in the protein
        auto_highlight : bool, optional
            Whether to automatically highlight high density regions if no regions are provided (default: True)
        auto_highlight_window : int, optional
            Window size for density smoothing when auto-highlighting (default: 10)
        auto_highlight_threshold : float, optional
            Threshold for density to be considered high (as a fraction of max density) (default: 0.8)
        highlight : bool, optional
            Whether to apply highlighting at all (default: True)
        color_by_protein_and_intensity : bool, optional
            Whether to color peptides by both protein and intensity (default: False)
        intensity_color_scale : float, optional
            How much the intensity should influence the color (0.0-1.0) (default: 0.7)
        intensity_cmaps : str or List[str], optional
            Colormaps for intensity visualization for each protein (default: &#34;viridis&#34;)
            If a string is provided, the same colormap is used for all proteins
            If a list is provided, each protein gets its own colormap from the list
            Options include: &#34;viridis&#34;, &#34;plasma&#34;, &#34;inferno&#34;, &#34;magma&#34;, &#34;cividis&#34;,
            &#34;Blues&#34;, &#34;Greens&#34;, &#34;Reds&#34;, &#34;Purples&#34;, &#34;Oranges&#34;, &#34;YlOrBr&#34;, &#34;YlGnBu&#34;, etc.
        protein_cmap : str, optional
            Colormap for protein visualization (default: &#34;tab10&#34;)
            Options: &#34;tab10&#34;, &#34;tab20&#34;, &#34;Pastel1&#34;, &#34;Pastel2&#34;, &#34;Set1&#34;, &#34;Set2&#34;, &#34;Set3&#34;
        external_legend : bool, optional
            Whether to place the legend outside the main plot (default: True)
        highlight_alpha : float, optional
            Alpha value for highlighted regions (default: 0.25)
        highlight_color : str, optional
            Color for highlighted regions (default: &#34;#FF8888&#34;)
        dpi : int, optional
            DPI for the figure (default: 100)
        &#34;&#34;&#34;

        # Convert single protein ID to list
        if isinstance(protein_ids, str):
            protein_ids = [protein_ids]
            
        # Filter data for the selected proteins
        data = self.peptide_data[self.peptide_data[&#39;Protein&#39;].isin(protein_ids)].copy()
        
        if data.empty:
            print(f&#34;No data found for proteins {protein_ids}&#34;)
            return
                
        # Apply intensity threshold if specified
        if min_intensity is not None:
            data = data[data[&#39;Intensity&#39;] &gt;= min_intensity]
                
        # Group peptides by their sequence
        peptide_groups = data.groupby([&#39;Peptide&#39;, &#39;Protein&#39;, &#39;Start&#39;, &#39;End&#39;]).agg({
            &#39;Intensity&#39;: [&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;],
            group_by: lambda x: list(set(x))
        }).reset_index()
            
        peptide_groups.columns = [&#39;Peptide&#39;, &#39;Protein&#39;, &#39;Start&#39;, &#39;End&#39;, &#39;Mean_Intensity&#39;, &#39;Std_Intensity&#39;, &#39;Count&#39;, &#39;Groups&#39;]
            
        # Determine groups to plot
        if groups is None:
            all_groups = []
            for g in peptide_groups[&#39;Groups&#39;]:
                all_groups.extend(g)
            groups = sorted(list(set(all_groups)))
        
        # Configure styling for publication-quality
        plt.style.use(&#39;default&#39;)
        plt.rcParams[&#39;font.family&#39;] = &#39;sans-serif&#39;
        plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial&#39;, &#39;Helvetica&#39;, &#39;DejaVu Sans&#39;]
        plt.rcParams[&#39;axes.linewidth&#39;] = 0.8
        plt.rcParams[&#39;xtick.major.width&#39;] = 0.8
        plt.rcParams[&#39;ytick.major.width&#39;] = 0.8
        plt.rcParams[&#39;xtick.direction&#39;] = &#39;out&#39;
        plt.rcParams[&#39;ytick.direction&#39;] = &#39;out&#39;
            
        # Set colors and style elements
        density_color = &#39;#555555&#39;      # Darker gray for density plots
        grid_color = &#39;#e5e5e5&#39;         # Very light gray grid
        separator_color = &#39;#cccccc&#39;    # Light gray separator
        background_color = &#39;#ffffff&#39;   # White background
        text_color = &#39;#333333&#39;         # Dark gray for text
            
        # Get proper colormaps
        try:
            protein_colormap = plt.cm.get_cmap(protein_cmap)
        except:
            # Default to tab10 if specified cmap doesn&#39;t exist
            protein_colormap = plt.cm.get_cmap(&#39;tab10&#39;)
                
        # Create map of proteins to colors
        protein_to_color = {}
        for i, protein in enumerate(protein_ids):
            color_idx = i % protein_colormap.N
            protein_to_color[protein] = protein_colormap(color_idx)
        
        # Set up available sequential colormaps
        sequential_cmaps = [
            &#34;viridis&#34;, &#34;plasma&#34;, &#34;inferno&#34;, &#34;magma&#34;, &#34;cividis&#34;,
            &#34;Blues&#34;, &#34;Greens&#34;, &#34;Reds&#34;, &#34;Purples&#34;, &#34;Oranges&#34;, 
            &#34;YlOrBr&#34;, &#34;YlOrRd&#34;, &#34;OrRd&#34;, &#34;PuRd&#34;, &#34;RdPu&#34;, 
            &#34;BuPu&#34;, &#34;GnBu&#34;, &#34;PuBu&#34;, &#34;YlGnBu&#34;, &#34;PuBuGn&#34;, 
            &#34;BuGn&#34;, &#34;YlGn&#34;
        ]
        
        # Set up intensity colormaps for each protein
        intensity_cmap_dict = {}
        
        # Handle the case where intensity_cmaps is a list
        if isinstance(intensity_cmaps, list):
            for i, protein_id in enumerate(protein_ids):
                # Get an intensity colormap for this protein
                cmap_idx = i % len(intensity_cmaps)
                cmap_name = intensity_cmaps[cmap_idx]
                
                # Ensure the colormap exists
                if cmap_name in sequential_cmaps or cmap_name in plt.colormaps():
                    intensity_cmap_dict[protein_id] = plt.cm.get_cmap(cmap_name)
                else:
                    # Fallback to a default sequential colormap
                    fallback_idx = i % len(sequential_cmaps)
                    intensity_cmap_dict[protein_id] = plt.cm.get_cmap(sequential_cmaps[fallback_idx])
        else:
            # If a single colormap is provided, use it for all proteins
            try:
                # Try to get the specified colormap
                cmap = plt.cm.get_cmap(intensity_cmaps)
                for protein_id in protein_ids:
                    intensity_cmap_dict[protein_id] = cmap
            except:
                # If it doesn&#39;t exist, assign a different sequential colormap to each protein
                for i, protein_id in enumerate(protein_ids):
                    cmap_idx = i % len(sequential_cmaps)
                    intensity_cmap_dict[protein_id] = plt.cm.get_cmap(sequential_cmaps[cmap_idx])
        
        # Set up figure with padding for external legend
        legend_width = 0.2 if external_legend else 0
        
        # Adjust figure size
        fig_width = figsize[0] + (figsize[0] * legend_width)
        fig_height = figsize[1]
        
        # Create figure
        n_groups = len(groups)
        fig = plt.figure(figsize=(fig_width, fig_height))
        
        # Define grid layout with space for legend
        if external_legend:
            gs = fig.add_gridspec(n_groups + 1, 2, width_ratios=[0.85, 0.15], height_ratios=[1] + [3] * n_groups)
            main_axes = []
            legend_axes = []
            
            # Create main plot axes
            for i in range(n_groups + 1):
                main_axes.append(fig.add_subplot(gs[i, 0]))
                if i &gt; 0:  # Don&#39;t share x for the first axis (density plot)
                    main_axes[i].sharex(main_axes[0])
            
            # Create legend axes
            legend_ax = fig.add_subplot(gs[0, 1])
            legend_ax.axis(&#39;off&#39;)
        else:
            gs = fig.add_gridspec(n_groups + 1, 1, height_ratios=[1] + [3] * n_groups)
            main_axes = []
            
            # Create main plot axes
            for i in range(n_groups + 1):
                main_axes.append(fig.add_subplot(gs[i, 0]))
                if i &gt; 0:  # Don&#39;t share x for the first axis (density plot)
                    main_axes[i].sharex(main_axes[0])
        
        axs = main_axes
        
        # Calculate limits
        min_start = int(peptide_groups[&#39;Start&#39;].min())
        max_end = int(peptide_groups[&#39;End&#39;].max())
        xlim = (min_start - 10, max_end + 10)
        
        # Set up the figure with proper styling
        for ax in axs:
            ax.set_facecolor(background_color)
            ax.grid(False)
            ax.tick_params(colors=text_color)
            for spine in ax.spines.values():
                spine.set_color(grid_color)
        
        # Initialize density profiles for each protein
        all_proteins_density = np.zeros(max_end - min_start + 1)
        protein_densities = {}
        
        # Plot protein overview at the top
        for protein_id in protein_ids:
            protein_peptides = peptide_groups[peptide_groups[&#39;Protein&#39;] == protein_id]
            
            if protein_peptides.empty:
                continue
                    
            # Create density profile for this protein
            positions = np.arange(min_start, max_end + 1)
            density = np.zeros(len(positions))
            
            for _, peptide in protein_peptides.iterrows():
                start, end = int(peptide[&#39;Start&#39;]), int(peptide[&#39;End&#39;])
                if start &lt; min_start:
                    start = min_start
                if end &gt; max_end:
                    end = max_end
                idx_start = start - min_start
                idx_end = end - min_start
                if idx_start &lt; len(density) and idx_end &lt;= len(density):
                    density[idx_start:idx_end] += 1
            
            # Store density for this protein
            protein_densities[protein_id] = density
            # Add to combined density
            all_proteins_density += density
            
            # Get color for this protein
            protein_color = protein_to_color[protein_id]
            
            # Plot density with publication-quality styling
            axs[0].bar(positions, density, color=protein_color, alpha=0.75, width=1, 
                    label=protein_id, edgecolor=None, linewidth=0)
            
            # Add elegant protein annotation
            if annotate and np.max(density) &gt; 0:
                max_pos = np.argmax(density) + min_start
                axs[0].annotate(protein_id, xy=(max_pos, np.max(density)),
                            xytext=(0, 5), textcoords=&#39;offset points&#39;,
                            ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=8,
                            bbox=dict(boxstyle=&#34;round,pad=0.2&#34;, 
                                    fc=background_color, ec=&#39;none&#39;, alpha=0.8),
                            color=text_color, weight=&#39;normal&#39;)
        
        # Auto-detect high density regions if requested
        auto_regions = []
        if highlight and auto_highlight and highlight_regions is None:
            # Apply smoothing to the density
            smoothed_density = self._smooth_density(all_proteins_density, window_size=auto_highlight_window)
            threshold = np.max(smoothed_density) * auto_highlight_threshold
            
            # Find regions above threshold
            high_density_regions = self._find_high_density_regions(smoothed_density, threshold, min_start)
            
            # Apply highlighting for auto-detected regions
            if high_density_regions:
                auto_regions = high_density_regions
                highlight_regions = high_density_regions
        
        # Styling for the top panel
        axs[0].set_xlim(xlim)
        axs[0].set_ylabel(&#39;Density&#39;, color=text_color, fontweight=&#39;normal&#39;, fontsize=10)
        axs[0].spines[&#39;top&#39;].set_visible(False)
        axs[0].spines[&#39;right&#39;].set_visible(False)
        axs[0].set_yticks([])
        
        # Create legend in the designated area if external
        if external_legend:
            # Create protein legend handles
            legend_handles = []
            for protein_id in protein_ids:
                patch = plt.Line2D([0], [0], color=protein_to_color[protein_id], lw=4, label=protein_id)
                legend_handles.append(patch)
            
            # Add legend to the separate legend axis
            protein_legend = legend_ax.legend(
                handles=legend_handles,
                loc=&#39;upper left&#39;,
                fontsize=9,
                frameon=True,
                framealpha=0.7,
                facecolor=background_color,
                edgecolor=grid_color,
                title=&#39;Proteins&#39;,
                title_fontsize=10
            )
            
            # Make sure legend title is properly formatted
            protein_legend.get_title().set_fontweight(&#39;bold&#39;)
        else:
            # Create protein legend in the main plot
            protein_legend = axs[0].legend(
                loc=&#39;upper right&#39;,
                fontsize=8,
                framealpha=0.7,
                facecolor=background_color,
                edgecolor=&#39;none&#39;,
                title=&#39;Proteins&#39;,
                title_fontsize=9
            )
            protein_legend.get_title().set_fontweight(&#39;normal&#39;)
        
        # Add subtle grid lines
        axs[0].grid(axis=&#39;x&#39;, linestyle=&#39;:&#39;, alpha=0.2, color=grid_color)
        
        # Highlight auto-detected regions in top panel with improved visibility
        if highlight and highlight_regions:
            for start, end in highlight_regions:
                # Make highlight more visible in top density panel
                axs[0].axvspan(start, end, alpha=highlight_alpha, color=highlight_color,
                            edgecolor=None, linewidth=0)
                
                # Add subtle lines to mark the region boundaries
                axs[0].axvline(start, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
                axs[0].axvline(end, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
        
        # Find global min/max intensity for consistent colormap normalization
        min_intensity_val = min_intensity if min_intensity is not None else peptide_groups[&#39;Mean_Intensity&#39;].min()
        max_intensity_val = peptide_groups[&#39;Mean_Intensity&#39;].max()
        
        # Create normalizations per protein to ensure consistent coloring
        protein_intensity_norms = {}
        for protein_id in protein_ids:
            protein_data = peptide_groups[peptide_groups[&#39;Protein&#39;] == protein_id]
            if not protein_data.empty:
                protein_min = min_intensity if min_intensity is not None else protein_data[&#39;Mean_Intensity&#39;].min()
                protein_max = protein_data[&#39;Mean_Intensity&#39;].max()
                protein_intensity_norms[protein_id] = plt.Normalize(protein_min, protein_max)
        
        # Plot peptides by group
        for i, group in enumerate(groups):
            ax = axs[i + 1]
            
            # Filter peptides for this group
            group_peptides = peptide_groups[peptide_groups[&#39;Groups&#39;].apply(lambda x: group in x)]
            
            if group_peptides.empty:
                ax.set_visible(False)
                continue
            
            # group_peptides[&#39;Length&#39;] = group_peptides[&#39;End&#39;] - group_peptides[&#39;Start&#39;]
            group_peptides.loc[:, &#39;Length&#39;] = group_peptides[&#39;End&#39;] - group_peptides[&#39;Start&#39;]

            # Calculate maximum height needed
            max_height = self._calculate_plot_height(group_peptides, xlim)
            
            # Initialize space tracking array
            spaces = np.zeros((max_height, int(xlim[1] - xlim[0] + 1)))
            
            # Sort peptides by start position and length
            group_peptides = group_peptides.sort_values([&#39;Start&#39;, &#39;End&#39;], ascending=[True, False])
            
            # Plot each peptide
            for idx, peptide in group_peptides.iterrows():
                start = int(peptide[&#39;Start&#39;])
                end = int(peptide[&#39;End&#39;])
                protein_id = peptide[&#39;Protein&#39;]
                
                # Get base color for this protein
                base_color = protein_to_color[protein_id]
                final_color = base_color
                
                # Apply coloring based on selection
                if color_by_protein_and_intensity:
                    # Get intensity value and normalize using per-protein normalization
                    intensity_val = peptide[&#39;Mean_Intensity&#39;]
                    
                    # Get normalization for this protein
                    if protein_id in protein_intensity_norms:
                        norm = protein_intensity_norms[protein_id]
                        intensity_normalized = norm(intensity_val)
                    else:
                        # Fallback to global normalization
                        intensity_normalized = plt.Normalize(min_intensity_val, max_intensity_val)(intensity_val)
                    
                    # Get the appropriate colormap for this protein
                    intensity_cmap = intensity_cmap_dict[protein_id]
                    
                    # Get color from the protein&#39;s intensity colormap
                    if intensity_normalized &lt; 0:
                        intensity_normalized = 0
                    elif intensity_normalized &gt; 1:
                        intensity_normalized = 1
                        
                    final_color = intensity_cmap(intensity_normalized)
                    
                elif color_by == &#39;intensity&#39;:
                    intensity_val = peptide[&#39;Mean_Intensity&#39;]
                    
                    # Use per-protein normalization and colormap
                    if protein_id in protein_intensity_norms:
                        norm = protein_intensity_norms[protein_id]
                        intensity_normalized = norm(intensity_val)
                    else:
                        # Fallback to global normalization
                        intensity_normalized = plt.Normalize(min_intensity_val, max_intensity_val)(intensity_val)
                    
                    # Use the protein&#39;s assigned colormap
                    intensity_cmap = intensity_cmap_dict[protein_id]
                    final_color = intensity_cmap(intensity_normalized)
                    
                elif color_by == &#39;count&#39;:
                    count_val = peptide[&#39;Count&#39;]
                    count_normalized = plt.Normalize(1, group_peptides[&#39;Count&#39;].max())(count_val)
                    final_color = plt.cm.Blues(count_normalized)
                    
                elif color_by == &#39;length&#39;:
                    length_val = peptide[&#39;End&#39;] - peptide[&#39;Start&#39;]
                    length_normalized = plt.Normalize(group_peptides[&#39;Length&#39;].min(), group_peptides[&#39;Length&#39;].max())(length_val)
                    final_color = plt.cm.Greens(length_normalized)
                
                # Find available space for this peptide
                for height in range(max_height):
                    if start &lt; xlim[0]:
                        start = xlim[0]
                    if end &gt; xlim[1]:
                        end = xlim[1]
                    
                    space_start = max(0, start - xlim[0])
                    space_end = min(end - xlim[0], xlim[1] - xlim[0])
                    
                    if space_start &gt;= spaces.shape[1] or space_end &gt;= spaces.shape[1]:
                        continue
                        
                    space_needed = spaces[height, space_start:space_end+1]
                    if np.sum(space_needed) == 0:  # Space is available
                        spaces[height, space_start:space_end+1] = 1
                        # Publication-quality peptide visualization
                        ax.plot(
                            [start, end], 
                            [-height-0.4, -height-0.4], 
                            linewidth=2.5,
                            solid_capstyle=&#39;round&#39;,
                            color=final_color,
                            alpha=0.95,
                            path_effects=[
                                path_effects.withStroke(
                                    linewidth=3.0, 
                                    foreground=(0, 0, 0, 0.2), 
                                    alpha=0.3
                                )
                            ]
                        )
                        break
            
            # Set plot limits and labels
            ax.set_ylim(-max_height, 0)
            ax.set_xlim(xlim)
            
            # Add styled group label - ensure it&#39;s visible and consistent
            ax.set_ylabel(group, fontweight=&#39;normal&#39;, color=text_color, fontsize=10)
            ax.set_yticks([])
            ax.spines[&#39;top&#39;].set_visible(False)
            ax.spines[&#39;right&#39;].set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)
            
            # Add subtle grid lines
            ax.grid(axis=&#39;x&#39;, linestyle=&#39;:&#39;, alpha=0.15, color=grid_color)
            
            # Add separator line
            ax.axhline(0, color=separator_color, linestyle=&#39;:&#39;, alpha=0.4, 
                    linewidth=0.8, dash_capstyle=&#39;round&#39;)
            
            # Highlight regions if specified and highlighting is enabled
            if highlight and highlight_regions:
                for start, end in highlight_regions:
                    # Apply highlighting with improved visibility
                    ax.axvspan(start, end, alpha=highlight_alpha, color=highlight_color,
                            edgecolor=None, linewidth=0)
                            
                    # Add subtle boundary lines
                    ax.axvline(start, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
                    ax.axvline(end, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
        
        # Set title
        if title is None:
            if len(protein_ids) == 1:
                title = f&#34;Peptide Coverage: {protein_ids[0]}&#34;
            else:
                title = f&#34;Protein Peptide Coverage Analysis&#34;
        
        plt.suptitle(title, fontsize=14, y=0.98, fontweight=&#39;bold&#39;, color=text_color)
        
        # Add subtitle if multiple proteins
        if len(protein_ids) &gt; 1:
            protein_str = &#34;, &#34;.join(protein_ids)
            if len(protein_str) &gt; 50:  # Truncate if too long
                protein_str = protein_str[:47] + &#34;...&#34;
            plt.figtext(0.5, 0.94, protein_str, ha=&#39;center&#39;, color=text_color, 
                    fontsize=9, fontstyle=&#39;italic&#39;)
        
        # Add subtitle for coloring method
        coloring_method = &#34;&#34;
        if color_by_protein_and_intensity:
            coloring_method = &#34;Colored by protein and intensity&#34;
        elif color_by == &#39;intensity&#39;:
            coloring_method = &#34;Colored by intensity&#34;
        elif color_by == &#39;protein&#39;:
            coloring_method = &#34;Colored by protein&#34;
        elif color_by == &#39;count&#39;:
            coloring_method = &#34;Colored by detection count&#34;
        elif color_by == &#39;length&#39;:
            coloring_method = &#34;Colored by peptide length&#34;
                
        if coloring_method:
            y_pos = 0.92 if len(protein_ids) &lt;= 1 else 0.90
            plt.figtext(0.5, y_pos, coloring_method, ha=&#39;center&#39;, color=text_color, 
                    fontsize=9, fontstyle=&#39;italic&#39;)
        
        # Add subtitle for auto-detected regions if applicable
        if auto_regions and len(auto_regions) &gt; 0:
            regions_str = &#34;, &#34;.join([f&#34;{start}-{end}&#34; for start, end in auto_regions])
            y_pos = 0.90 if len(protein_ids) &lt;= 1 and not coloring_method else 0.88
            plt.figtext(0.5, y_pos, f&#34;Auto-highlighted regions: {regions_str}&#34;, 
                    ha=&#39;center&#39;, fontsize=9, fontstyle=&#39;italic&#39;, color=highlight_color)
        
        # Set x-label on the bottom axis only
        axs[-1].set_xlabel(&#39;Amino Acid Position&#39;, fontweight=&#39;normal&#39;, color=text_color, fontsize=10)
        
        # Add intensity colorbars for each protein if using protein+intensity
        if color_by_protein_and_intensity and external_legend:
            # Calculate how much space each colorbar needs
            colorbar_height = 0.7 / len(protein_ids)
            colorbar_padding = 0.02
            
            for i, protein_id in enumerate(protein_ids):
                if protein_id not in protein_intensity_norms:
                    continue
                    
                # Calculate position for this colorbar
                bottom_position = 0.75 - (i * (colorbar_height + colorbar_padding))
                position = [0.88, bottom_position, 0.03, colorbar_height]
                
                # Create axes for the colorbar
                cax = fig.add_axes(position)
                
                # Get the appropriate colormap and normalization
                cmap = intensity_cmap_dict[protein_id]
                norm = protein_intensity_norms[protein_id]
                
                # Create colorbar
                sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
                sm.set_array([])
                cbar = plt.colorbar(sm, cax=cax)
                
                # Add the protein ID as the label
                cbar.set_label(f&#39;{protein_id}&#39;, fontweight=&#39;bold&#39;, fontsize=8)
                cbar.ax.tick_params(labelsize=7)
        
        # Add a label for the intensity legend
        if color_by_protein_and_intensity and external_legend:
            legend_label_ypos = 0.85
            legend_ax.text(0.5, legend_label_ypos, &#39;Intensity Scales&#39;, 
                        horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;,
                        transform=legend_ax.transAxes, fontsize=10, fontweight=&#39;bold&#39;)
        
        # Apply final layout adjustments
        plt.tight_layout()
        plt.subplots_adjust(hspace=0.05, top=0.9)
        
        # Set DPI for higher quality
        fig.set_dpi(dpi)
        
        return fig, axs
    
    def _calculate_plot_height(self, peptide_data: pd.DataFrame, xlim: Tuple[int, int]) -&gt; int:
        &#34;&#34;&#34;
        Calculate the required height for plotting peptides without overlap.
        &#34;&#34;&#34;
        # Sort peptides by start position and length
        peptides = peptide_data.sort_values([&#39;Start&#39;, &#39;Length&#39;], ascending=[True, False])
        
        # Initialize space tracking array
        spaces = np.zeros((100, int(xlim[1] - xlim[0] + 1)))
        max_height = 0
        
        # Track required height
        for _, peptide in peptides.iterrows():
            start = int(peptide[&#39;Start&#39;])
            end = int(peptide[&#39;End&#39;])
            
            # Skip peptides outside plot range
            if end &lt; xlim[0] or start &gt; xlim[1]:
                continue
                
            # Adjust to plot coordinates
            plot_start = max(0, start - xlim[0])
            plot_end = min(end - xlim[0], xlim[1] - xlim[0])
            
            # Find available space
            placed = False
            for height in range(spaces.shape[0]):
                if height &gt; max_height:
                    max_height = height
                
                if plot_start &gt;= spaces.shape[1] or plot_end &gt;= spaces.shape[1]:
                    continue
                    
                space_needed = spaces[height, plot_start:plot_end+1]
                if np.sum(space_needed) == 0:  # Space is available
                    spaces[height, plot_start:plot_end+1] = 1
                    placed = True
                    break
            
            # If no space found, we need more height
            if not placed:
                max_height = spaces.shape[0]
        
        return max_height + 1  # Add 1 for padding
    
    def _adjust_color(self, color, value):
        &#34;&#34;&#34;
        Adjust color based on intensity value.
        &#34;&#34;&#34;
        # Convert string colors to RGB
        if isinstance(color, str):
            color = plt.matplotlib.colors.to_rgba(color)
            
        # For darker values, maintain more of the original color but adjust brightness
        r, g, b, a = color
        
        # Adjust color based on value while preserving hue
        if value &lt; 0.5:
            # Darken
            factor = 0.5 + value
            r = r * factor
            g = g * factor
            b = b * factor
        else:
            # Lighten
            factor = value - 0.5
            r = r + (1 - r) * factor
            g = g + (1 - g) * factor
            b = b + (1 - b) * factor
            
        return (r, g, b, a)
    
    def _adjust_color_by_intensity(self, color, intensity, scale_factor=0.7):
        &#34;&#34;&#34;
        Adjust color by intensity while preserving the protein&#39;s base color.
        Enhanced version for better visibility of intensity differences.
        
        Parameters:
        -----------
        color : tuple or str
            Base color to adjust
        intensity : float (0-1)
            Normalized intensity value
        scale_factor : float (0-1)
            How much the intensity should influence the color (default: 0.7)
            Higher values make intensity differences more pronounced
            
        Returns:
        --------
        tuple: (r, g, b, a) color
        &#34;&#34;&#34;
        # Convert string colors to RGB
        if isinstance(color, str):
            color = plt.matplotlib.colors.to_rgba(color)
            
        r, g, b, a = color
        
        # Enhanced color adjustment:
        # For low intensity (0-0.5), darken the color significantly
        # For high intensity (0.5-1.0), brighten and increase saturation
        
        if intensity &lt; 0.5:
            # Map 0-0.5 to 0.1-0.5 (avoid going completely black)
            mapped_intensity = 0.1 + intensity * 0.8
            # Apply non-linear darkening for better differentiation
            factor = mapped_intensity ** (1.5 * scale_factor)
            
            # Preserve hue but reduce brightness
            new_r = r * factor
            new_g = g * factor
            new_b = b * factor
        else:
            # Map 0.5-1.0 to 0.5-1.2 (allow some brightening beyond original)
            mapped_intensity = 0.5 + (intensity - 0.5) * 1.4
            
            # For high intensity: preserve or increase saturation while brightening
            # Find dominant color channel to preserve hue
            max_channel = max(r, g, b)
            if max_channel == 0:
                # If color is black, just use gray scale
                new_r = new_g = new_b = mapped_intensity
            else:
                # Calculate how much to brighten each channel
                factor = mapped_intensity / max_channel
                
                # Brighten proportionally to preserve hue
                new_r = min(1, r * factor * (1 + scale_factor * 0.5))
                new_g = min(1, g * factor * (1 + scale_factor * 0.5))
                new_b = min(1, b * factor * (1 + scale_factor * 0.5))
        
        # Ensure values stay in valid range
        new_r = max(0, min(1, new_r))
        new_g = max(0, min(1, new_g))
        new_b = max(0, min(1, new_b))
        
        return (new_r, new_g, new_b, a)
    
    def _smooth_density(self, density, window_size=10):
        &#34;&#34;&#34;
        Apply smoothing to density array for better peak detection.
        
        Parameters:
        -----------
        density : np.ndarray
            Density array to smooth
        window_size : int, optional
            Size of the smoothing window (default: 10)
            
        Returns:
        --------
        np.ndarray: Smoothed density
        &#34;&#34;&#34;
        # Create simple moving average smoothing
        kernel = np.ones(window_size) / window_size
        smoothed = np.convolve(density, kernel, mode=&#39;same&#39;)
        
        # Handle edge effects by replacing edges with original values
        half_window = window_size // 2
        smoothed[:half_window] = density[:half_window]
        smoothed[-half_window:] = density[-half_window:]
        
        return smoothed

    def _find_high_density_regions(self, density, threshold, min_start, min_region_size=5, max_gap=3):
        &#34;&#34;&#34;
        Find regions with high peptide density.
        
        Parameters:
        -----------
        density : np.ndarray
            Density array (smoothed)
        threshold : float
            Threshold value for high density
        min_start : int
            Minimum starting position (for coordinate adjustment)
        min_region_size : int, optional
            Minimum size of a region to be considered (default: 5)
        max_gap : int, optional
            Maximum gap between high density points to be considered same region (default: 3)
        
        Returns:
        --------
        List[Tuple[int, int]]: List of (start, end) high density regions
        &#34;&#34;&#34;
        # Find positions above threshold
        high_density_positions = np.where(density &gt;= threshold)[0]
        
        if len(high_density_positions) == 0:
            return []
        
        # Group positions into contiguous regions
        regions = []
        current_region_start = high_density_positions[0]
        prev_pos = high_density_positions[0]
        
        for pos in high_density_positions[1:]:
            # If there&#39;s a gap larger than max_gap, end the current region
            if pos - prev_pos &gt; max_gap:
                if prev_pos - current_region_start + 1 &gt;= min_region_size:
                    regions.append((current_region_start + min_start, prev_pos + min_start + 1))
                current_region_start = pos
            prev_pos = pos
        
        # Add the last region if it meets minimum size
        if prev_pos - current_region_start + 1 &gt;= min_region_size:
            regions.append((current_region_start + min_start, prev_pos + min_start + 1))
        
        # Merge overlapping regions
        if len(regions) &gt; 1:
            regions.sort()
            merged_regions = [regions[0]]
            
            for current in regions[1:]:
                previous = merged_regions[-1]
                if current[0] &lt;= previous[1]:
                    # Regions overlap, merge them
                    merged_regions[-1] = (previous[0], max(previous[1], current[1]))
                else:
                    # No overlap, add as new region
                    merged_regions.append(current)
            
            regions = merged_regions
        
        return regions
    
    def export_peptogram(self, protein_ids: Union[str, List[str]], output_file: str, **kwargs):
        &#34;&#34;&#34;
        Create and save a PeptiGram visualization to a file.
        &#34;&#34;&#34;
        fig, _ = self.plot_peptigram(protein_ids, **kwargs)
        fig.savefig(output_file, dpi=300, bbox_inches=&#39;tight&#39;)
        plt.close(fig)
        print(f&#34;PeptiGram saved to {output_file}&#34;)</code></pre>
</details>
<div class="desc"><p>A visualization tool for immunopeptide data from mass spectrometry results.
Enhanced version with sequential colormaps and advanced visualization options.</p>
<p>Initialize the ImmunoViz object with peptide data.</p>
<h2 id="parameters">Parameters:</h2>
<p>peptide_data : pd.DataFrame
DataFrame containing peptide information with columns:
- Peptide: sequence of the peptide
- Protein: protein identifier
- Start: start position in the protein
- End: end position in the protein
- Intensity: intensity value from mass spec
- Sample: sample identifier</p></div>
<h3>Methods</h3>
<dl>
<dt id="ProtPeptigram.viz.ImmunoViz.export_peptogram"><code class="name flex">
<span>def <span class="ident">export_peptogram</span></span>(<span>self, protein_ids: str | List[str], output_file: str, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_peptogram(self, protein_ids: Union[str, List[str]], output_file: str, **kwargs):
    &#34;&#34;&#34;
    Create and save a PeptiGram visualization to a file.
    &#34;&#34;&#34;
    fig, _ = self.plot_peptigram(protein_ids, **kwargs)
    fig.savefig(output_file, dpi=300, bbox_inches=&#39;tight&#39;)
    plt.close(fig)
    print(f&#34;PeptiGram saved to {output_file}&#34;)</code></pre>
</details>
<div class="desc"><p>Create and save a PeptiGram visualization to a file.</p></div>
</dd>
<dt id="ProtPeptigram.viz.ImmunoViz.plot_peptigram"><code class="name flex">
<span>def <span class="ident">plot_peptigram</span></span>(<span>self,<br>protein_ids: str | List[str],<br>groups: List[str] = None,<br>group_by: str = 'Sample',<br>color_by: str = 'protein',<br>figsize: Tuple[int, int] = (12, 10),<br>title: str | None = None,<br>annotate: bool = True,<br>min_intensity: float | None = None,<br>highlight_regions: List[Tuple[int, int]] | None = None,<br>auto_highlight: bool = True,<br>auto_highlight_window: int = 10,<br>auto_highlight_threshold: float = 0.8,<br>highlight: bool = True,<br>color_by_protein_and_intensity: bool = False,<br>intensity_color_scale: float = 0.7,<br>intensity_cmaps: str | List[str] = 'viridis',<br>protein_cmap: str = 'tab10',<br>external_legend: bool = True,<br>highlight_alpha: float = 0.25,<br>highlight_color: str = '#FF8888',<br>dpi: int = 100)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_peptigram(
    self,
    protein_ids: Union[str, List[str]],
    groups: List[str] = None,
    group_by: str = &#39;Sample&#39;,
    color_by: str = &#39;protein&#39;,
    figsize: Tuple[int, int] = (12, 10),
    title: Optional[str] = None,
    annotate: bool = True,
    min_intensity: Optional[float] = None,
    highlight_regions: Optional[List[Tuple[int, int]]] = None,
    auto_highlight: bool = True,
    auto_highlight_window: int = 10,
    auto_highlight_threshold: float = 0.8,
    highlight: bool = True,
    color_by_protein_and_intensity: bool = False,
    intensity_color_scale: float = 0.7,
    intensity_cmaps: Union[str, List[str]] = &#34;viridis&#34;,
    protein_cmap: str = &#34;tab10&#34;,
    external_legend: bool = True,
    highlight_alpha: float = 0.25,
    highlight_color: str = &#34;#FF8888&#34;,
    dpi: int = 100
):
    &#34;&#34;&#34;
    Create a PeptiGram visualization with protein-based coloring.
    
    Parameters:
    -----------
    protein_ids : str or List[str]
        Protein identifier(s) to visualize
    groups : List[str], optional
        List of group names to include (if None, all groups are included)
    group_by : str, optional
        Column name to group samples by (default: &#39;Sample&#39;)
    color_by : str, optional
        How to color peptides: &#39;intensity&#39;, &#39;count&#39;, &#39;length&#39;, or &#39;protein&#39; (default: &#39;protein&#39;)
    figsize : Tuple[int, int], optional
        Figure size (width, height) in inches (default: (12, 10))
    title : str, optional
        Title for the plot (default: &#34;Protein Peptide Coverage&#34;)
    annotate : bool, optional
        Whether to annotate proteins (default: True)
    min_intensity : float, optional
        Minimum intensity threshold (default: None)
    highlight_regions : List[Tuple[int, int]], optional
        List of (start, end) regions to highlight in the protein
    auto_highlight : bool, optional
        Whether to automatically highlight high density regions if no regions are provided (default: True)
    auto_highlight_window : int, optional
        Window size for density smoothing when auto-highlighting (default: 10)
    auto_highlight_threshold : float, optional
        Threshold for density to be considered high (as a fraction of max density) (default: 0.8)
    highlight : bool, optional
        Whether to apply highlighting at all (default: True)
    color_by_protein_and_intensity : bool, optional
        Whether to color peptides by both protein and intensity (default: False)
    intensity_color_scale : float, optional
        How much the intensity should influence the color (0.0-1.0) (default: 0.7)
    intensity_cmaps : str or List[str], optional
        Colormaps for intensity visualization for each protein (default: &#34;viridis&#34;)
        If a string is provided, the same colormap is used for all proteins
        If a list is provided, each protein gets its own colormap from the list
        Options include: &#34;viridis&#34;, &#34;plasma&#34;, &#34;inferno&#34;, &#34;magma&#34;, &#34;cividis&#34;,
        &#34;Blues&#34;, &#34;Greens&#34;, &#34;Reds&#34;, &#34;Purples&#34;, &#34;Oranges&#34;, &#34;YlOrBr&#34;, &#34;YlGnBu&#34;, etc.
    protein_cmap : str, optional
        Colormap for protein visualization (default: &#34;tab10&#34;)
        Options: &#34;tab10&#34;, &#34;tab20&#34;, &#34;Pastel1&#34;, &#34;Pastel2&#34;, &#34;Set1&#34;, &#34;Set2&#34;, &#34;Set3&#34;
    external_legend : bool, optional
        Whether to place the legend outside the main plot (default: True)
    highlight_alpha : float, optional
        Alpha value for highlighted regions (default: 0.25)
    highlight_color : str, optional
        Color for highlighted regions (default: &#34;#FF8888&#34;)
    dpi : int, optional
        DPI for the figure (default: 100)
    &#34;&#34;&#34;

    # Convert single protein ID to list
    if isinstance(protein_ids, str):
        protein_ids = [protein_ids]
        
    # Filter data for the selected proteins
    data = self.peptide_data[self.peptide_data[&#39;Protein&#39;].isin(protein_ids)].copy()
    
    if data.empty:
        print(f&#34;No data found for proteins {protein_ids}&#34;)
        return
            
    # Apply intensity threshold if specified
    if min_intensity is not None:
        data = data[data[&#39;Intensity&#39;] &gt;= min_intensity]
            
    # Group peptides by their sequence
    peptide_groups = data.groupby([&#39;Peptide&#39;, &#39;Protein&#39;, &#39;Start&#39;, &#39;End&#39;]).agg({
        &#39;Intensity&#39;: [&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;],
        group_by: lambda x: list(set(x))
    }).reset_index()
        
    peptide_groups.columns = [&#39;Peptide&#39;, &#39;Protein&#39;, &#39;Start&#39;, &#39;End&#39;, &#39;Mean_Intensity&#39;, &#39;Std_Intensity&#39;, &#39;Count&#39;, &#39;Groups&#39;]
        
    # Determine groups to plot
    if groups is None:
        all_groups = []
        for g in peptide_groups[&#39;Groups&#39;]:
            all_groups.extend(g)
        groups = sorted(list(set(all_groups)))
    
    # Configure styling for publication-quality
    plt.style.use(&#39;default&#39;)
    plt.rcParams[&#39;font.family&#39;] = &#39;sans-serif&#39;
    plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial&#39;, &#39;Helvetica&#39;, &#39;DejaVu Sans&#39;]
    plt.rcParams[&#39;axes.linewidth&#39;] = 0.8
    plt.rcParams[&#39;xtick.major.width&#39;] = 0.8
    plt.rcParams[&#39;ytick.major.width&#39;] = 0.8
    plt.rcParams[&#39;xtick.direction&#39;] = &#39;out&#39;
    plt.rcParams[&#39;ytick.direction&#39;] = &#39;out&#39;
        
    # Set colors and style elements
    density_color = &#39;#555555&#39;      # Darker gray for density plots
    grid_color = &#39;#e5e5e5&#39;         # Very light gray grid
    separator_color = &#39;#cccccc&#39;    # Light gray separator
    background_color = &#39;#ffffff&#39;   # White background
    text_color = &#39;#333333&#39;         # Dark gray for text
        
    # Get proper colormaps
    try:
        protein_colormap = plt.cm.get_cmap(protein_cmap)
    except:
        # Default to tab10 if specified cmap doesn&#39;t exist
        protein_colormap = plt.cm.get_cmap(&#39;tab10&#39;)
            
    # Create map of proteins to colors
    protein_to_color = {}
    for i, protein in enumerate(protein_ids):
        color_idx = i % protein_colormap.N
        protein_to_color[protein] = protein_colormap(color_idx)
    
    # Set up available sequential colormaps
    sequential_cmaps = [
        &#34;viridis&#34;, &#34;plasma&#34;, &#34;inferno&#34;, &#34;magma&#34;, &#34;cividis&#34;,
        &#34;Blues&#34;, &#34;Greens&#34;, &#34;Reds&#34;, &#34;Purples&#34;, &#34;Oranges&#34;, 
        &#34;YlOrBr&#34;, &#34;YlOrRd&#34;, &#34;OrRd&#34;, &#34;PuRd&#34;, &#34;RdPu&#34;, 
        &#34;BuPu&#34;, &#34;GnBu&#34;, &#34;PuBu&#34;, &#34;YlGnBu&#34;, &#34;PuBuGn&#34;, 
        &#34;BuGn&#34;, &#34;YlGn&#34;
    ]
    
    # Set up intensity colormaps for each protein
    intensity_cmap_dict = {}
    
    # Handle the case where intensity_cmaps is a list
    if isinstance(intensity_cmaps, list):
        for i, protein_id in enumerate(protein_ids):
            # Get an intensity colormap for this protein
            cmap_idx = i % len(intensity_cmaps)
            cmap_name = intensity_cmaps[cmap_idx]
            
            # Ensure the colormap exists
            if cmap_name in sequential_cmaps or cmap_name in plt.colormaps():
                intensity_cmap_dict[protein_id] = plt.cm.get_cmap(cmap_name)
            else:
                # Fallback to a default sequential colormap
                fallback_idx = i % len(sequential_cmaps)
                intensity_cmap_dict[protein_id] = plt.cm.get_cmap(sequential_cmaps[fallback_idx])
    else:
        # If a single colormap is provided, use it for all proteins
        try:
            # Try to get the specified colormap
            cmap = plt.cm.get_cmap(intensity_cmaps)
            for protein_id in protein_ids:
                intensity_cmap_dict[protein_id] = cmap
        except:
            # If it doesn&#39;t exist, assign a different sequential colormap to each protein
            for i, protein_id in enumerate(protein_ids):
                cmap_idx = i % len(sequential_cmaps)
                intensity_cmap_dict[protein_id] = plt.cm.get_cmap(sequential_cmaps[cmap_idx])
    
    # Set up figure with padding for external legend
    legend_width = 0.2 if external_legend else 0
    
    # Adjust figure size
    fig_width = figsize[0] + (figsize[0] * legend_width)
    fig_height = figsize[1]
    
    # Create figure
    n_groups = len(groups)
    fig = plt.figure(figsize=(fig_width, fig_height))
    
    # Define grid layout with space for legend
    if external_legend:
        gs = fig.add_gridspec(n_groups + 1, 2, width_ratios=[0.85, 0.15], height_ratios=[1] + [3] * n_groups)
        main_axes = []
        legend_axes = []
        
        # Create main plot axes
        for i in range(n_groups + 1):
            main_axes.append(fig.add_subplot(gs[i, 0]))
            if i &gt; 0:  # Don&#39;t share x for the first axis (density plot)
                main_axes[i].sharex(main_axes[0])
        
        # Create legend axes
        legend_ax = fig.add_subplot(gs[0, 1])
        legend_ax.axis(&#39;off&#39;)
    else:
        gs = fig.add_gridspec(n_groups + 1, 1, height_ratios=[1] + [3] * n_groups)
        main_axes = []
        
        # Create main plot axes
        for i in range(n_groups + 1):
            main_axes.append(fig.add_subplot(gs[i, 0]))
            if i &gt; 0:  # Don&#39;t share x for the first axis (density plot)
                main_axes[i].sharex(main_axes[0])
    
    axs = main_axes
    
    # Calculate limits
    min_start = int(peptide_groups[&#39;Start&#39;].min())
    max_end = int(peptide_groups[&#39;End&#39;].max())
    xlim = (min_start - 10, max_end + 10)
    
    # Set up the figure with proper styling
    for ax in axs:
        ax.set_facecolor(background_color)
        ax.grid(False)
        ax.tick_params(colors=text_color)
        for spine in ax.spines.values():
            spine.set_color(grid_color)
    
    # Initialize density profiles for each protein
    all_proteins_density = np.zeros(max_end - min_start + 1)
    protein_densities = {}
    
    # Plot protein overview at the top
    for protein_id in protein_ids:
        protein_peptides = peptide_groups[peptide_groups[&#39;Protein&#39;] == protein_id]
        
        if protein_peptides.empty:
            continue
                
        # Create density profile for this protein
        positions = np.arange(min_start, max_end + 1)
        density = np.zeros(len(positions))
        
        for _, peptide in protein_peptides.iterrows():
            start, end = int(peptide[&#39;Start&#39;]), int(peptide[&#39;End&#39;])
            if start &lt; min_start:
                start = min_start
            if end &gt; max_end:
                end = max_end
            idx_start = start - min_start
            idx_end = end - min_start
            if idx_start &lt; len(density) and idx_end &lt;= len(density):
                density[idx_start:idx_end] += 1
        
        # Store density for this protein
        protein_densities[protein_id] = density
        # Add to combined density
        all_proteins_density += density
        
        # Get color for this protein
        protein_color = protein_to_color[protein_id]
        
        # Plot density with publication-quality styling
        axs[0].bar(positions, density, color=protein_color, alpha=0.75, width=1, 
                label=protein_id, edgecolor=None, linewidth=0)
        
        # Add elegant protein annotation
        if annotate and np.max(density) &gt; 0:
            max_pos = np.argmax(density) + min_start
            axs[0].annotate(protein_id, xy=(max_pos, np.max(density)),
                        xytext=(0, 5), textcoords=&#39;offset points&#39;,
                        ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=8,
                        bbox=dict(boxstyle=&#34;round,pad=0.2&#34;, 
                                fc=background_color, ec=&#39;none&#39;, alpha=0.8),
                        color=text_color, weight=&#39;normal&#39;)
    
    # Auto-detect high density regions if requested
    auto_regions = []
    if highlight and auto_highlight and highlight_regions is None:
        # Apply smoothing to the density
        smoothed_density = self._smooth_density(all_proteins_density, window_size=auto_highlight_window)
        threshold = np.max(smoothed_density) * auto_highlight_threshold
        
        # Find regions above threshold
        high_density_regions = self._find_high_density_regions(smoothed_density, threshold, min_start)
        
        # Apply highlighting for auto-detected regions
        if high_density_regions:
            auto_regions = high_density_regions
            highlight_regions = high_density_regions
    
    # Styling for the top panel
    axs[0].set_xlim(xlim)
    axs[0].set_ylabel(&#39;Density&#39;, color=text_color, fontweight=&#39;normal&#39;, fontsize=10)
    axs[0].spines[&#39;top&#39;].set_visible(False)
    axs[0].spines[&#39;right&#39;].set_visible(False)
    axs[0].set_yticks([])
    
    # Create legend in the designated area if external
    if external_legend:
        # Create protein legend handles
        legend_handles = []
        for protein_id in protein_ids:
            patch = plt.Line2D([0], [0], color=protein_to_color[protein_id], lw=4, label=protein_id)
            legend_handles.append(patch)
        
        # Add legend to the separate legend axis
        protein_legend = legend_ax.legend(
            handles=legend_handles,
            loc=&#39;upper left&#39;,
            fontsize=9,
            frameon=True,
            framealpha=0.7,
            facecolor=background_color,
            edgecolor=grid_color,
            title=&#39;Proteins&#39;,
            title_fontsize=10
        )
        
        # Make sure legend title is properly formatted
        protein_legend.get_title().set_fontweight(&#39;bold&#39;)
    else:
        # Create protein legend in the main plot
        protein_legend = axs[0].legend(
            loc=&#39;upper right&#39;,
            fontsize=8,
            framealpha=0.7,
            facecolor=background_color,
            edgecolor=&#39;none&#39;,
            title=&#39;Proteins&#39;,
            title_fontsize=9
        )
        protein_legend.get_title().set_fontweight(&#39;normal&#39;)
    
    # Add subtle grid lines
    axs[0].grid(axis=&#39;x&#39;, linestyle=&#39;:&#39;, alpha=0.2, color=grid_color)
    
    # Highlight auto-detected regions in top panel with improved visibility
    if highlight and highlight_regions:
        for start, end in highlight_regions:
            # Make highlight more visible in top density panel
            axs[0].axvspan(start, end, alpha=highlight_alpha, color=highlight_color,
                        edgecolor=None, linewidth=0)
            
            # Add subtle lines to mark the region boundaries
            axs[0].axvline(start, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
            axs[0].axvline(end, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
    
    # Find global min/max intensity for consistent colormap normalization
    min_intensity_val = min_intensity if min_intensity is not None else peptide_groups[&#39;Mean_Intensity&#39;].min()
    max_intensity_val = peptide_groups[&#39;Mean_Intensity&#39;].max()
    
    # Create normalizations per protein to ensure consistent coloring
    protein_intensity_norms = {}
    for protein_id in protein_ids:
        protein_data = peptide_groups[peptide_groups[&#39;Protein&#39;] == protein_id]
        if not protein_data.empty:
            protein_min = min_intensity if min_intensity is not None else protein_data[&#39;Mean_Intensity&#39;].min()
            protein_max = protein_data[&#39;Mean_Intensity&#39;].max()
            protein_intensity_norms[protein_id] = plt.Normalize(protein_min, protein_max)
    
    # Plot peptides by group
    for i, group in enumerate(groups):
        ax = axs[i + 1]
        
        # Filter peptides for this group
        group_peptides = peptide_groups[peptide_groups[&#39;Groups&#39;].apply(lambda x: group in x)]
        
        if group_peptides.empty:
            ax.set_visible(False)
            continue
        
        # group_peptides[&#39;Length&#39;] = group_peptides[&#39;End&#39;] - group_peptides[&#39;Start&#39;]
        group_peptides.loc[:, &#39;Length&#39;] = group_peptides[&#39;End&#39;] - group_peptides[&#39;Start&#39;]

        # Calculate maximum height needed
        max_height = self._calculate_plot_height(group_peptides, xlim)
        
        # Initialize space tracking array
        spaces = np.zeros((max_height, int(xlim[1] - xlim[0] + 1)))
        
        # Sort peptides by start position and length
        group_peptides = group_peptides.sort_values([&#39;Start&#39;, &#39;End&#39;], ascending=[True, False])
        
        # Plot each peptide
        for idx, peptide in group_peptides.iterrows():
            start = int(peptide[&#39;Start&#39;])
            end = int(peptide[&#39;End&#39;])
            protein_id = peptide[&#39;Protein&#39;]
            
            # Get base color for this protein
            base_color = protein_to_color[protein_id]
            final_color = base_color
            
            # Apply coloring based on selection
            if color_by_protein_and_intensity:
                # Get intensity value and normalize using per-protein normalization
                intensity_val = peptide[&#39;Mean_Intensity&#39;]
                
                # Get normalization for this protein
                if protein_id in protein_intensity_norms:
                    norm = protein_intensity_norms[protein_id]
                    intensity_normalized = norm(intensity_val)
                else:
                    # Fallback to global normalization
                    intensity_normalized = plt.Normalize(min_intensity_val, max_intensity_val)(intensity_val)
                
                # Get the appropriate colormap for this protein
                intensity_cmap = intensity_cmap_dict[protein_id]
                
                # Get color from the protein&#39;s intensity colormap
                if intensity_normalized &lt; 0:
                    intensity_normalized = 0
                elif intensity_normalized &gt; 1:
                    intensity_normalized = 1
                    
                final_color = intensity_cmap(intensity_normalized)
                
            elif color_by == &#39;intensity&#39;:
                intensity_val = peptide[&#39;Mean_Intensity&#39;]
                
                # Use per-protein normalization and colormap
                if protein_id in protein_intensity_norms:
                    norm = protein_intensity_norms[protein_id]
                    intensity_normalized = norm(intensity_val)
                else:
                    # Fallback to global normalization
                    intensity_normalized = plt.Normalize(min_intensity_val, max_intensity_val)(intensity_val)
                
                # Use the protein&#39;s assigned colormap
                intensity_cmap = intensity_cmap_dict[protein_id]
                final_color = intensity_cmap(intensity_normalized)
                
            elif color_by == &#39;count&#39;:
                count_val = peptide[&#39;Count&#39;]
                count_normalized = plt.Normalize(1, group_peptides[&#39;Count&#39;].max())(count_val)
                final_color = plt.cm.Blues(count_normalized)
                
            elif color_by == &#39;length&#39;:
                length_val = peptide[&#39;End&#39;] - peptide[&#39;Start&#39;]
                length_normalized = plt.Normalize(group_peptides[&#39;Length&#39;].min(), group_peptides[&#39;Length&#39;].max())(length_val)
                final_color = plt.cm.Greens(length_normalized)
            
            # Find available space for this peptide
            for height in range(max_height):
                if start &lt; xlim[0]:
                    start = xlim[0]
                if end &gt; xlim[1]:
                    end = xlim[1]
                
                space_start = max(0, start - xlim[0])
                space_end = min(end - xlim[0], xlim[1] - xlim[0])
                
                if space_start &gt;= spaces.shape[1] or space_end &gt;= spaces.shape[1]:
                    continue
                    
                space_needed = spaces[height, space_start:space_end+1]
                if np.sum(space_needed) == 0:  # Space is available
                    spaces[height, space_start:space_end+1] = 1
                    # Publication-quality peptide visualization
                    ax.plot(
                        [start, end], 
                        [-height-0.4, -height-0.4], 
                        linewidth=2.5,
                        solid_capstyle=&#39;round&#39;,
                        color=final_color,
                        alpha=0.95,
                        path_effects=[
                            path_effects.withStroke(
                                linewidth=3.0, 
                                foreground=(0, 0, 0, 0.2), 
                                alpha=0.3
                            )
                        ]
                    )
                    break
        
        # Set plot limits and labels
        ax.set_ylim(-max_height, 0)
        ax.set_xlim(xlim)
        
        # Add styled group label - ensure it&#39;s visible and consistent
        ax.set_ylabel(group, fontweight=&#39;normal&#39;, color=text_color, fontsize=10)
        ax.set_yticks([])
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        
        # Add subtle grid lines
        ax.grid(axis=&#39;x&#39;, linestyle=&#39;:&#39;, alpha=0.15, color=grid_color)
        
        # Add separator line
        ax.axhline(0, color=separator_color, linestyle=&#39;:&#39;, alpha=0.4, 
                linewidth=0.8, dash_capstyle=&#39;round&#39;)
        
        # Highlight regions if specified and highlighting is enabled
        if highlight and highlight_regions:
            for start, end in highlight_regions:
                # Apply highlighting with improved visibility
                ax.axvspan(start, end, alpha=highlight_alpha, color=highlight_color,
                        edgecolor=None, linewidth=0)
                        
                # Add subtle boundary lines
                ax.axvline(start, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
                ax.axvline(end, color=highlight_color, linestyle=&#39;-&#39;, alpha=0.3, linewidth=0.8)
    
    # Set title
    if title is None:
        if len(protein_ids) == 1:
            title = f&#34;Peptide Coverage: {protein_ids[0]}&#34;
        else:
            title = f&#34;Protein Peptide Coverage Analysis&#34;
    
    plt.suptitle(title, fontsize=14, y=0.98, fontweight=&#39;bold&#39;, color=text_color)
    
    # Add subtitle if multiple proteins
    if len(protein_ids) &gt; 1:
        protein_str = &#34;, &#34;.join(protein_ids)
        if len(protein_str) &gt; 50:  # Truncate if too long
            protein_str = protein_str[:47] + &#34;...&#34;
        plt.figtext(0.5, 0.94, protein_str, ha=&#39;center&#39;, color=text_color, 
                fontsize=9, fontstyle=&#39;italic&#39;)
    
    # Add subtitle for coloring method
    coloring_method = &#34;&#34;
    if color_by_protein_and_intensity:
        coloring_method = &#34;Colored by protein and intensity&#34;
    elif color_by == &#39;intensity&#39;:
        coloring_method = &#34;Colored by intensity&#34;
    elif color_by == &#39;protein&#39;:
        coloring_method = &#34;Colored by protein&#34;
    elif color_by == &#39;count&#39;:
        coloring_method = &#34;Colored by detection count&#34;
    elif color_by == &#39;length&#39;:
        coloring_method = &#34;Colored by peptide length&#34;
            
    if coloring_method:
        y_pos = 0.92 if len(protein_ids) &lt;= 1 else 0.90
        plt.figtext(0.5, y_pos, coloring_method, ha=&#39;center&#39;, color=text_color, 
                fontsize=9, fontstyle=&#39;italic&#39;)
    
    # Add subtitle for auto-detected regions if applicable
    if auto_regions and len(auto_regions) &gt; 0:
        regions_str = &#34;, &#34;.join([f&#34;{start}-{end}&#34; for start, end in auto_regions])
        y_pos = 0.90 if len(protein_ids) &lt;= 1 and not coloring_method else 0.88
        plt.figtext(0.5, y_pos, f&#34;Auto-highlighted regions: {regions_str}&#34;, 
                ha=&#39;center&#39;, fontsize=9, fontstyle=&#39;italic&#39;, color=highlight_color)
    
    # Set x-label on the bottom axis only
    axs[-1].set_xlabel(&#39;Amino Acid Position&#39;, fontweight=&#39;normal&#39;, color=text_color, fontsize=10)
    
    # Add intensity colorbars for each protein if using protein+intensity
    if color_by_protein_and_intensity and external_legend:
        # Calculate how much space each colorbar needs
        colorbar_height = 0.7 / len(protein_ids)
        colorbar_padding = 0.02
        
        for i, protein_id in enumerate(protein_ids):
            if protein_id not in protein_intensity_norms:
                continue
                
            # Calculate position for this colorbar
            bottom_position = 0.75 - (i * (colorbar_height + colorbar_padding))
            position = [0.88, bottom_position, 0.03, colorbar_height]
            
            # Create axes for the colorbar
            cax = fig.add_axes(position)
            
            # Get the appropriate colormap and normalization
            cmap = intensity_cmap_dict[protein_id]
            norm = protein_intensity_norms[protein_id]
            
            # Create colorbar
            sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
            sm.set_array([])
            cbar = plt.colorbar(sm, cax=cax)
            
            # Add the protein ID as the label
            cbar.set_label(f&#39;{protein_id}&#39;, fontweight=&#39;bold&#39;, fontsize=8)
            cbar.ax.tick_params(labelsize=7)
    
    # Add a label for the intensity legend
    if color_by_protein_and_intensity and external_legend:
        legend_label_ypos = 0.85
        legend_ax.text(0.5, legend_label_ypos, &#39;Intensity Scales&#39;, 
                    horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;,
                    transform=legend_ax.transAxes, fontsize=10, fontweight=&#39;bold&#39;)
    
    # Apply final layout adjustments
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.05, top=0.9)
    
    # Set DPI for higher quality
    fig.set_dpi(dpi)
    
    return fig, axs</code></pre>
</details>
<div class="desc"><p>Create a PeptiGram visualization with protein-based coloring.</p>
<h2 id="parameters">Parameters:</h2>
<p>protein_ids : str or List[str]
Protein identifier(s) to visualize
groups : List[str], optional
List of group names to include (if None, all groups are included)
group_by : str, optional
Column name to group samples by (default: 'Sample')
color_by : str, optional
How to color peptides: 'intensity', 'count', 'length', or 'protein' (default: 'protein')
figsize : Tuple[int, int], optional
Figure size (width, height) in inches (default: (12, 10))
title : str, optional
Title for the plot (default: "Protein Peptide Coverage")
annotate : bool, optional
Whether to annotate proteins (default: True)
min_intensity : float, optional
Minimum intensity threshold (default: None)
highlight_regions : List[Tuple[int, int]], optional
List of (start, end) regions to highlight in the protein
auto_highlight : bool, optional
Whether to automatically highlight high density regions if no regions are provided (default: True)
auto_highlight_window : int, optional
Window size for density smoothing when auto-highlighting (default: 10)
auto_highlight_threshold : float, optional
Threshold for density to be considered high (as a fraction of max density) (default: 0.8)
highlight : bool, optional
Whether to apply highlighting at all (default: True)
color_by_protein_and_intensity : bool, optional
Whether to color peptides by both protein and intensity (default: False)
intensity_color_scale : float, optional
How much the intensity should influence the color (0.0-1.0) (default: 0.7)
intensity_cmaps : str or List[str], optional
Colormaps for intensity visualization for each protein (default: "viridis")
If a string is provided, the same colormap is used for all proteins
If a list is provided, each protein gets its own colormap from the list
Options include: "viridis", "plasma", "inferno", "magma", "cividis",
"Blues", "Greens", "Reds", "Purples", "Oranges", "YlOrBr", "YlGnBu", etc.
protein_cmap : str, optional
Colormap for protein visualization (default: "tab10")
Options: "tab10", "tab20", "Pastel1", "Pastel2", "Set1", "Set2", "Set3"
external_legend : bool, optional
Whether to place the legend outside the main plot (default: True)
highlight_alpha : float, optional
Alpha value for highlighted regions (default: 0.25)
highlight_color : str, optional
Color for highlighted regions (default: "#FF8888")
dpi : int, optional
DPI for the figure (default: 100)</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ProtPeptigram" href="index.html">ProtPeptigram</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ProtPeptigram.viz.ImmunoViz" href="#ProtPeptigram.viz.ImmunoViz">ImmunoViz</a></code></h4>
<ul class="">
<li><code><a title="ProtPeptigram.viz.ImmunoViz.export_peptogram" href="#ProtPeptigram.viz.ImmunoViz.export_peptogram">export_peptogram</a></code></li>
<li><code><a title="ProtPeptigram.viz.ImmunoViz.plot_peptigram" href="#ProtPeptigram.viz.ImmunoViz.plot_peptigram">plot_peptigram</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
